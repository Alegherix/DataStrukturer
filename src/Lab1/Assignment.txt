The assignment
Your first job is to implement the three sorting algorithms as follows:

insertionSort should implement insertion sort. It should use the optimisation discussed in the lecture where you move elements upwards instead of swapping. The algorithm should sort in-place, i.e. no temporary extra array should be used.

quickSort should implement quicksort, picking the first element of the array as the pivot. The algorithm should sort in-place, i.e. no temporary extra array should be used. Note: your version of quicksort might crash with STACK OVERFLOW for large sorted inputs.
This is allowed for sorted arrays of size 30000 and 100000 but not in any other cases.

mergeSort should implement mergesort. As merge sort is not done in-place, the method returns a new array instead of modifying the existing one.
You will probably find the existing skeleton code and helper methods useful, but they are only a suggested way to structure your implementation: if you have a better idea, go for it! But you must not change the types of the sorting methods themselves.

Once all the algorithms are working, your second job is to compare their performance by looking at the benchmark results. It’s up to you what you look at, but in the end you should write a few sentences to say when you would recommend each algorithm. Questions you could answer include:

Is there a size cutoff at which a different algorithm becomes best?
How does the type of test data affect which algorithm you should choose?
Which should you choose if you don’t know anything about the test data?
Are there circumstances when you should definitely avoid a certain algorithm?
Submission
You should submit the following things:

Your final Lab1.java.
The output of the benchmark program and your performance recommendations in a text file.